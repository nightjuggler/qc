#!/usr/bin/python
#
# Various functions to test qc.py
#
import math
from qc import *

def testSuperdenseCoding(a1, a2):
	#
	# Send two classical bits a1 and a2 via superdense coding using entangled qubits A and B
	#
	qA, qB = 'A', 'B'
	clearSystem()

	b1, b2 = sendSuperdense(a1, a2, qA, qB)
	assert a1 == b1 and a2 == b2

def testTeleport1():
	#
	# Create a qubit C and teleport its state (via A) to qubit B
	#
	qA, qB, qC = 'A', 'B', 'C'
	clearSystem()

	createQubit(qC, 0.6, 0.8)
	printQubit(qC)

	teleportQubit(qC, qA, qB)
	printQubit(qB)

def testTeleport2():
	#
	# Entangle A with B and teleport the state of A to D (via C)
	#
	qA, qB, qC, qD = 'A', 'B', 'C', 'D'
	clearSystem()

	prepareBell(qA, qB)
	printQubit(qA)

	teleportQubit(qA, qC, qD)

	# Now D is entangled with B
	printQubit(qD)
	b1 = measureQubit(qD)
	printQubit(qD)
	printQubit(qB)
	b2 = measureQubit(qB)
	assert b1 == b2

def measure5050():
	qA, qB = 'A', 'B'
	prepareBell(qA, qB)
	b1 = measureQubit(qA)
	b2 = measureQubit(qB)
	assert b1 == b2
	return b1

def measure3664():
	createQubit('A', 0.6, 0.8)
	return measureQubit('A')

def measure23_13_23_41():
	qA, qB = 'A', 'B'
	createQubit(qA, 0.6, 0.8)
	createQubit(qB, 0.8, 0.6)
	applyGate(ControlledNotGate, qA, qB)
	b1 = measureQubit(qA)
	b2 = measureQubit(qB)
	return (b1 << 1) + b2

def testRandomness(getMeasurement):
	count = [0] * 16
	for i in xrange(0, 10000):
		clearSystem()
		m = getMeasurement()
		count[m] += 1
	for m, c in enumerate(count):
		if c > 0:
			print '{:04b}: {}'.format(m, c)

def testQFT():
	clearSystem()

	x = qubitArray('x', 5)
	createQubit(x[0], 0.6, 0.8)
	createQubit(x[1], 0.8, 0.6)
	createQubit(x[2], 1.0, 0.0)
	prepareBell(x[3], x[4])
	applyGate(FourierTransform(1 << len(x)), *x)

	y = qubitArray('y', 5)
	createQubit(y[0], 0.6, 0.8)
	createQubit(y[1], 0.8, 0.6)
	createQubit(y[2], 1.0, 0.0)
	prepareBell(y[3], y[4])
	quantumFourierTransform(y)

	compareStateVectors(x[0], y[0], verbose=True)

def compareMatrices(X, Y, verbose=True):
	rX = roundedMatrix(X)
	rY = roundedMatrix(Y)

	equal = True
	for row, (rowX, rowY) in enumerate(zip(rX, rY)):
		for col, (a, b) in enumerate(zip(rowX, rowY)):
			if a != b and abs(a - b) > 1.5e-14:
				equal = False
				if verbose:
					print "X[{0},{1}] != Y[{0},{1}]:".format(row, col)
					print "X[{},{}] = {:.16f}".format(row, col, a)
					print "Y[{},{}] = {:.16f}".format(row, col, b)
					print
	return equal

def constructQFT3():
	ct = combineTransforms
	mm = multiplyMatrixByMatrix

	H = HadamardGate
	I = IdentityMatrix
	S = SwapGate

	R2 = ControlledGate(PhaseShiftGate(math.pi / 2))
	R4 = ControlledGate(PhaseShiftGate(math.pi / 4))

	HI = ct(H, I)
	HII = ct(HI, I)
	R2S = mm(R2, S)
	R2SI = ct(mm(R2, S), I)
	IR4S = ct(I, mm(R4, S))

	F = [[1]]
	F = ct(F, I)
	F = mm(H, F)
	F = ct(F, I)
	F = mm(R2S, F)
	F = mm(HI, F)

	compareMatrices(F, FourierTransform(1 << 2))

	F = ct(F, I)
	F = mm(IR4S, F)
	F = mm(R2SI, F)
	F = mm(HII, F)

	compareMatrices(F, FourierTransform(1 << 3))

def multiplyWith(F, gate, gateName, numBefore, numAfter, verbose):
	for i in xrange(numBefore):
		gate = combineTransforms(IdentityMatrix, gate)
		gateName = 'I' + gateName

	for i in xrange(numAfter):
		gate = combineTransforms(gate, IdentityMatrix)
		gateName = gateName + 'I'

	if verbose:
		print "F = mm({}, F)".format(gateName)

	return multiplyMatrixByMatrix(gate, F)

def constructQFT(N, verbose=False):
	#
	# This function iteratively builds up the matrix F for the quantum Fourier transform
	# for vectors of length 2^N (N qubits), starting from the 1x1 identity matrix (which
	# is just F for N=0). F is multiplied by the matrices for the swap gate, the Hadamard
	# gate, and the controlled phase shift gates. Before multiplication with F, each of
	# these gate matrices, which act on either one qubit (the Hadamard) or two adjacent
	# qubits, is "padded" with 2x2 identity matrices for the qubits that are not acted on
	# by the gate. This padding is done by calling combineTransforms() (which returns the
	# Kronecker product of two matrices) in the above helper function.
	#
	# The matrix generated by this method should be equivalent to the one generated by the
	# FourierTransform function in qc.py (with argument 1<<N instead of N).
	#
	assert N >= 0

	F = [[1]]
	for i in xrange(N):
		# Add x[i]
		if verbose:
			print "F = ct(F, I)"
		F = combineTransforms(F, IdentityMatrix)

		# Swap x[i] with x[i-1], then swap x[i-1] with x[i-2], and so on until the
		# original x[i] becomes x[0]. Along the way, after each swap, apply the
		# controlled phase gate R(pi/2^(i-j)) on the qubits that were just swapped.
		for j in xrange(i):
			piDivisor = 1 << (i - j)
			gate = ControlledGate(PhaseShiftGate(math.pi / piDivisor))
			gate = multiplyMatrixByMatrix(gate, SwapGate)
			gateName = "R{}S".format(piDivisor)
			F = multiplyWith(F, gate, gateName, i - 1 - j, j, verbose)

		# Apply the Hadamard gate to x[i] (now x[0])
		F = multiplyWith(F, HadamardGate, 'H', 0, i, verbose)

	compareMatrices(F, FourierTransform(1 << N))

if __name__ == '__main__':
	testSuperdenseCoding(0, 0)
	testSuperdenseCoding(0, 1)
	testSuperdenseCoding(1, 0)
	testSuperdenseCoding(1, 1)

#	testTeleport1()
#	testTeleport2()

#	testRandomness(measure5050)
#	testRandomness(measure3664)
#	testRandomness(measure23_13_23_41)

	testQFT()
	constructQFT3()
	constructQFT(5)
